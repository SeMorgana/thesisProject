from constants import *
import ipaddr
import gc
import geopy.distance
import numpy as np

from utility import JI

class LG(object):
    def __init__(self, id_ ,set_nei=None, num_rel=None, as_info=None, list_prefix=None, lat_lon=None):
        '''
        args:
            id_:
                as-lg string
            set_nei:
                (set(neighbors), set(internal neighbors), set(external neighbors))
            num_rel:
                (#i, #unknown, #cp, #pc, #p2p)
            ?as_info:
                ?(type, tier)
            list_prefix:
                ([i1,i2,...in], [unknown1, unknown2..], [cp1..], [..] ,[..])
            lat_lon:
                (lat, lon), both are float
            

            ##############################################################################
            below are attributes generated by calling functions from LG instance, instead of 
            calling from utility module:

            prefix_as_path:
                d[prefix] -> list of AS paths


        values got on demand:
        ip int: get_ip_int() returns it
        prefix-as_path: update_prefix_as_path() updates it

        
        '''
        d_attr = dict()
        d_attr[ID] = id_
        d_attr[NEI_SET] = set_nei
        d_attr[NUM_REL] = num_rel
        d_attr[AS_INFO] = as_info#?
        d_attr[LIST_PREFIX] = list_prefix
        d_attr[LAT_LON] = lat_lon

        self.__dict__.update(d_attr)

    def __eq__(self, other):
        '''
        '''
        return self.get_attr(ID) == other.get_attr(ID)
    
    def __hash__(self):
        return hash(self.get_attr(ID))

    def __str__(self):
        '''
        '''
        return self.get_attr(ID)

    def get_attr(self, attr):
        '''
        '''
        assert(attr in self.__dict__.keys())
        return self.__dict__[attr]
    
    def set_attr(self, attr, value):
        '''
        '''
        assert(attr in self.__dict__.keys())
        self.__dict__[attr] = value

    def size_nei(self):
        '''
        '''
        return len(self.get_attr(NEI_SET)[0])

    def get_ip_int(self):
        '''
        '''
        ip = self.get_attr(ID).split("-")[1]
        ip_obj = ipaddr.IPv4Address(ip)
        return int(ip_obj)

    def update_prefix_as_path(self):
        '''
        !!!call release after use
        for the current LG, get all the prefixes and AS paths corresponding to each prefix
        d: prefix->list of as_paths
        '''
        import os
        path = os.path.join(PREFIX_AS_PATH_DIR,self.get_attr(ID))
        assert (os.path.isfile(path))
        self.__dict__[PREFIX_AS_PATH] = dict()
        d = self.__dict__[PREFIX_AS_PATH] #for convinience
        f = open(path)
        for line in f:
            if "network" in line:   #skip the first line
                continue
            parts = line.rstrip().split("\t")
            prefix = parts[0]
            as_path = parts[1]
            if prefix in d:
                d[prefix].append(as_path)
            else:
                d[prefix] = [as_path]

    def get_prefixes(self):
        '''
        should be called after update_prefix_as_path() is called
        return:
            a set of prefixes
        '''
        return set(self.__dict__[PREFIX_AS_PATH])

    def get_as_paths(self, prefix):
        '''
        should be called after update_prefix_as_path() is called
        args:
            the prefix to be looked up
        return:
            a list of as paths for the prefix
        '''
        d = self.__dict__[PREFIX_AS_PATH]
        return d[prefix]

    def get_as_paths_set(self, prefix):
        '''
        should be called after update_prefix_as_path() is called
        args:
            the prefix to be looked up
        return:
            a set of single asn after spliting for the prefix, if there are more 
            than one path for the prefix, mix them all for now!!
        '''
        d = self.__dict__[PREFIX_AS_PATH]
        l = d[prefix]
        s = set()
        for as_path in l:
            for asn in as_path.split():
                s.add(asn)
        return s

    def release(self):
        '''
        release the space used by PREFIX_AS_PATH
        '''
        self.__dict__[PREFIX_AS_PATH] = None
        gc.collect()
                

    def distance(self, other):
        '''
        args:
            other: the other LG object
        return:
            distance between this LG and other LG in km,, float("nan") if one of the 
            coords is unknown(i.e. (0.0,0.0))
        '''
        coords1 = self.get_attr(LAT_LON)
        coords2 = other.get_attr(LAT_LON)
        if coords1 == (0,0) or coords2 == (0,0):
            return float("nan")
        return geopy.distance.great_circle(coords1,coords2).km

    def mean_ji_aspath(self,other):
        '''
        '''
        self.update_prefix_as_path()
        p1 = self.get_prefixes()
        other.update_prefix_as_path()
        p2 = other.get_prefixes()
        overlap = p1 & p2
        if len(overlap) == 0:#no overlapping prefixes
            return float("nan")

        tmp = []
        for p in overlap:
            s1 = self.get_as_paths_set(p)
            s2 = other.get_as_paths_set(p)
            tmp.append(JI(s1,s2))


        self.release()
        other.release()
        return np.mean(tmp)


    def validate(self):
        '''
        '''
        num_rel = self.get_attr(NUM_REL)
        list_prefix = self.get_attr(LIST_PREFIX)
        for i,n in enumerate(num_rel):
            assert n == len(list_prefix[i])

    @classmethod
    def dummy(cls):
        return LG("", (set(),set(),set()), (0,0,0,0,0), ("na","na"), ([],[],[],[],[]))
